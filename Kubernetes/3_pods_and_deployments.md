# Pods and Deployments in Kubernetes

## 📚 What is a ReplicaSet?

A **ReplicaSet** is a Kubernetes resource that ensures a specified number of pod replicas are running at any given time.

- It watches over the state of the pods and replaces any that fail or are deleted.
- ReplicaSets are rarely managed directly; they are usually created and managed by **Deployments**.
- When you update a Deployment, Kubernetes creates a new ReplicaSet and gradually shifts traffic from the old one.

### 🔍 How It Tracks Pods: Template Hashing

Each ReplicaSet uses a **hash of the Pod template** (from `.spec.template`) to uniquely identify and manage its pods.

- If you change the pod spec (e.g. image, labels), the hash changes.
- This causes the Deployment to spin up a **new ReplicaSet** with a new hash.
- Kubernetes uses this mechanism to manage **rolling updates** and **version history**.

Example of a ReplicaSet (auto-generated by a Deployment):

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: example-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: myapp:latest
```

This ensures 3 pods of `myapp` are always running, and uniquely tracked by the hashed template.

---

## 🔄 Rolling Updates and Strategies

In Kubernetes, **Deployments** support rolling updates by default, allowing you to update your applications **without downtime**. The update strategy is controlled using two important fields:

- `maxSurge`: How many **extra Pods** can be added **above the desired number of replicas** during the update.
- `maxUnavailable`: How many **existing Pods** can be **taken down** at once during the update.

These fields are part of the `rollingUpdate` strategy inside a Deployment.

When using a rolling update strategy your application changes will need to be backward compatible, meaning that the new version of your application should be able to handle requests from both the old and new versions of your application.

---

### ⚙️ How `maxSurge` and `maxUnavailable` Work

Suppose you have a Deployment with:

```yaml
replicas: 4
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 1
```

This means:
- During the update, Kubernetes can **launch 1 extra pod** (up to 5 total) before terminating an old one.
- At most, **1 old pod can be unavailable** at any time.

So Kubernetes will:
1. Launch 1 new pod (now 5 total)
2. Terminate 1 old pod (back to 4)
3. Repeat the process until all 4 are updated

This ensures:
- There's always at least **3 working pods** (4 desired − 1 unavailable)
- There’s a small temporary **capacity buffer** of +1 pod during rollout

---

### 🧪 Example Rolling Update Strategy

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 4
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: myapp:v2
```

When you apply this Deployment with a new image, Kubernetes will:
- Add 1 new pod running `v2`
- Remove 1 old pod running `v1`
- Repeat the process until all pods are on `v2`

---

### 📌 Strategy Tips

- `maxSurge: 0` and `maxUnavailable: 1` = conservative, minimal overhead
- `maxSurge: 100%` and `maxUnavailable: 0` = fast updates with extra capacity
- You can use **absolute values (e.g., `2`)** or **percentages (e.g., `25%`)**

---

### 🔢 Rounding Rules for `maxSurge` and `maxUnavailable`

When using **percentages**, Kubernetes applies rounding as follows:

- **`maxSurge` is rounded _up_** to the nearest whole number.
- **`maxUnavailable` is rounded _down_** to the nearest whole number.

#### Example:
For a Deployment with `replicas: 3`:

```yaml
rollingUpdate:
  maxSurge: 30%        # → rounded UP to 1
  maxUnavailable: 30%  # → rounded DOWN to 0
```

This means:
- Kubernetes can temporarily create 1 extra pod
- All 3 original pods must stay available (no disruption)

These rounding rules are designed to be **safe by default**, ensuring high availability during updates.

---